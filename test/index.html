---
layout: lesson
title: Testing
children : [
    {"path" : "intro.html", "title" : "Introduction"},
    {"path" : "except.html", "title" : "Exceptions"},
    {"path" : "unit.html", "title" : "Unit Testing"},
    {"path" : "interface.html", "title" : "Interface and Implementation"},
    {"path" : "float.html", "title" : "Floating Point"},
    {"path" : "fixture.html", "title" : "Fixtures"}
]
prev: v4/python/index.html
next: v4/setdict/index.html
uplink: v4/index.html
---
<div class="overview">
  <p>
    It's pretty obvious that if we want to be sure our programs are right,
    we need to put in some effort.
    What isn't so obvious is that
    focusing on quality is also the best way&mdash;in fact, the <em>only</em> way&mdash;to
    improve productivity as well.
    Getting something wrong and then fixing it
    almost always takes longer than getting it right in the first place.
    Designing testable code,
    practicing defensive programming,
    writing and running tests,
    and thinking about what the right answer is supposed to be
    all help get us answers faster,
    as well as ones that are more likely to be correct.
  </p>
</div>

<div class="well well-small">
  <ul class="keypoints">
    <li>Testing can't find all mistakes, any more than proof-reading can find all typos, but both are still useful.</li>
    <li>Use exceptions to report and handle errors: throw low, catch high.</li>
    <li>Use an xUnit library to manage unit tests in a uniform, predictable way.</li>
    <li>Isolating components for testing also improves code quality.</li>
    <li>Use approximate comparisons when dealing with floating point numbers.</li>
    <li>Separate test setup and teardown from test execution.</li>
  </ul>
</div>
